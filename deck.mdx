<!-- Begin setup -->
import {useState} from 'react';
import Layout from "./components/layout";
import BabelRepl from "./components/babel-repl";
import LiveEditor from "./components/live-editor";
import SoloEditor from "./components/solo-editor";
import { Logo } from "./components/shared";
import reactUsage from "./assets/react-usage.png";
// import CodeSandbox from "./components/CodeSandbox";


import baseTheme from "./theme";

export const theme = baseTheme;


<Head>
  <title>Slides | React Information Flow</title>
  <link
    rel="shortcut icon"
    type="image/x-icon"
    href="https://instructure-uploads.s3.amazonaws.com/account_158020000000000001/attachments/43718/flatiron-favicon.ico"
  />
</Head>

<!-- End setup -->

<!-- Begin Slide -->

<Layout>

## React Information Flow

<Logo />

</Layout>

<Notes>



</Notes>

<!-- End Slide -->

---

# [Questions?](https://docs.google.com/document/d/1iAtutIgh8L-WSi6TaURiAmq_S5yglduQCNx3x9qI29o/edit#)

<iframe width="1000" height="800" src="https://docs.google.com/document/d/1iAtutIgh8L-WSi6TaURiAmq_S5yglduQCNx3x9qI29o/edit#"></iframe>

<Notes>

If you have any questions throughout lecture and you want to make sure they don't get lost in the chat, feel free to add them to this google doc and let me know! We'll come back and take a look at it together and fill in some answers and notes.

</Notes>

---

<!-- Begin Slide -->

<Layout>

# âœ… Objectives

<Steps>

- Revisit our component hierarchy and describe the Flow of Information
- Decide which components should have state
- Pass data _up_ with callbacks, and _down_ with props 

</Steps>

</Layout>

<Notes>



</Notes>

<!-- End Slide -->

--- 

<!-- Begin Slide -->

<Layout>

## ğŸ“… Agenda

<Steps>

- Take a look at the component Hierarchy and decide where data will flow from component to component
- Integrate JSON-Server into our application
- Add a button to allow fetching data from server
- Use Inverse Data flow to implement Light-Dark mode
- Exercise: Implement Inverse Data flow to fix a broken search feature

</Steps>

</Layout>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

## Deliverables

- Add a button to our App that will use json-server to fetch projects and store them in state
- Implement the light mode/dark mode functionality

</Layout>

<Notes>



</Notes>

<!-- End Slide -->

--- 

<!-- Begin Slide -->

<Layout>

### ğŸ¤” Decisions - Should it be state?

From Step 3 of
[Thinking in React](https://reactjs.org/docs/thinking-in-react.html): to decide
what we need as `state`, ask three questions about each piece of data:

- Is it passed in from a parent via props? If so, it probably isnâ€™t state.
- Does it remain unchanged over time? If so, it probably isnâ€™t state.
- Can you compute it based on any other state or props in your component? If so,
  it isnâ€™t state.

</Layout>

<Notes>



</Notes>

<!-- End Slide -->

--- 

<!-- Begin Slide -->

<Layout>

### ğŸ¤” Decisions - Where should state be?

From Step 4 of Thinking in React: To decide where state should live, for each
piece of state in your application:

- Identify every component that renders something based on that state.
- Find a common owner component (a single component above all the components
  that need the state in the hierarchy).
- Either the common owner or another component higher up in the hierarchy should
  own the state.
- If you canâ€™t find a component where it makes sense to own the state, create a
  new component solely for holding the state and add it somewhere in the
  hierarchy above the common owner component.

</Layout>

<Notes>



</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

## Data Flow

![Component Hierarchy with Data Flow](https://res.cloudinary.com/dnocv6uwb/image/upload/v1643912910/component-hierarchy-with-data-flow_cq3qkl.png)

where else do we need access to projects?
<br/>

</Layout>

<Notes>



</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

## Introducing JSON-server

<Steps>

- add "server" script to our package.json that will run the json-server --watch command on port 4000
- rework App component to integrate fetched data

</Steps>

</Layout>

<Notes>



</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

# â˜•ï¸â˜•ï¸â˜•ï¸â˜•ï¸â˜•ï¸â˜•ï¸â˜•ï¸â˜•ï¸ 
# Break!
# ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸

</Layout>

<Notes>



</Notes>

<!-- End Slide -->

--- 

<!-- Begin Slide -->

<Layout>

## Integrating Light/Dark mode

<Steps>

- Currently, we have our isDarkMode state within the `Header` component. 
- What's the problem with that? How are we actually implementing Dark and Light styles?
- Let's go fix it!


</Steps>

</Layout>

<Notes>



</Notes>

<!-- End Slide -->

---

<!-- Begin Slide -->

<Layout>

## Diagram!
![React Inverse Data Flow Diagram](https://res.cloudinary.com/dnocv6uwb/image/upload/v1643914430/react-inverse-data-flow-diagram_dzkos1.png)

</Layout>

<Notes>



</Notes>

<!-- End Slide -->

--- 

<!-- Begin Slide -->

<Layout>

# â˜•ï¸â˜•ï¸â˜•ï¸â˜•ï¸â˜•ï¸â˜•ï¸â˜•ï¸â˜•ï¸ 
# Break!
# ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸ğŸ™†â€â™‚ï¸

</Layout>

<Notes>



</Notes>

<!-- End Slide -->

--- 


<!-- Begin Slide -->


## ğŸ‹ï¸â€â™‚ï¸ Exercise ğŸ‹ï¸â€â™‚ï¸

Implement Inverse Data flow to fix a broken search feature

[Open Codesandbox](https://codesandbox.io/s/inverse-data-flow-exercise-otvjp?file=/src/App.js) - instructions in `src/App.js`

<iframe src="https://codesandbox.io/embed/inverse-data-flow-exercise-otvjp?fontsize=14&hidenavigation=1&theme=dark"
  style={{"width":"100%", height:"500px"}}
  title="Inverse Data Flow exercise"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>




<Notes>



</Notes>

<!-- End Slide -->

--- 

# Recap of Key Skills

- introduce state to our application so that 
  - user behavior -> update state -> React updates DOM
- deciding what things should be state and what should be props

